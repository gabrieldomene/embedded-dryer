#include <secagem.h>
#include <lcd.c>

#int_timer0
void trata_t0()
{  
   int y;
   int x;
   y = y + 1;
   int valor;
      char c;
   static boolean led;
   set_timer0(131);
   if(y == 250 && x == 0){
      
      
      //Limpa lcd
      c='\f';
      lcd_putc(c);
      
      //Escolhe canal
      set_adc_channel(0);        //Seta o canal AN0 com entrada anal?gica
      delay_us(10);              //tempo necess?rio para o hardware ficar pronto
      //Leitura analogica
      valor = LER_TEMPERATURA();
      //Escreve no LCD
      printf(LCD_PUTC, "Temp = %u'",valor);
      output_high(pin_b1);
      delay_ms(500);
      x = x+1;
   }else if(y == 250 && x == 1){
      //Limpa lcd
      c='\f';
      lcd_putc(c);
      //Escreve no LCD
      printf(LCD_PUTC, "TROCA DE MSG'");
      output_low(pin_b1);
      delay_ms(500);
      x = 0;
   }
}
void main()
{
   Port_b_pullups(true);
   
   output_low(pin_b1);
   lcd_init();
   setup_adc_ports(AN0);             //configura porta AN0 com entrada anal?gica
   setup_adc(ADC_CLOCK_INTERNAL);    //usar? o clock interno do AD(mais comum)
   
   
   //setup_timer_1(T1_INTERNAL);
   //setup_timer_1(RTCC_DIV_8);
   setup_timer_0 ( RTCC_INTERNAL | RTCC_DIV_64 );  // timer0 com clock interno e dividido por 64
   set_timer0(131);                                         // carrega o valor 131 no registrador do timer
   enable_interrupts (global | int_ext | int_timer0);
   ext_int_edge(H_to_L);
   //habilita as interrup??es
   
   int1 reserva;
   int1 safety;
   while(TRUE)
   {      
      reserva = input(pin_b2);
      delay_ms(200);
      safety = input(pin_b3);
      //Ver se reservatório tem produto, lógica inversa 0 = S // 1 = N
      if(reserva == 0)
      {
         output_high(pin_b3);
      }else{
         output_low(pin_b3);
      }
   }

}
